# 서론

- Go에서 **"동시성 프로그래밍"**을 사용할 수 있도록 고루틴을 제공해줌
- 동시성과 병렬성은 다른 것

# 고루틴과 쓰레드의 차이

## 메모리 소비

- 고루틴은 오직 2KB의 스택 공간만 필요로 한다.
- 고루틴을 할당하고 필요에 따라 힙 저장공간을 확보하여 사용
- 반대로 쓰레드는 쓰레드의 메모리와 다른 쓰레드의 메모리 간의 경비 역할을 하는 Guard page라고 불리는 메모리 영역과 더불어 1MB로 시작한다.
- 따라서 request를 처리할 때 고루틴은 요청당 한 개씩 만들 수 있지만, 하나의 쓰레드는 결과적으로 OOM이 발생하게 될 것이다.
- 동시성 주요 수단으로 OS 쓰레드를 사용하는 언어가 모두 가지고 있는 문제

## 설치와 철거비용

- 쓰레드는 OS로부터 리소스를 요청해야 하고 작업이 끝나면 리소스를 돌려줘야한다.
    - 이 문제의 차선책으로는 쓰레드의 Pool을 유지하는 것
- 그러나 고루틴은 런타임에서 만들어지고 파괴되는 작업들이 저렴하다.
    - 따라서 Go는 고루틴에 대한 매뉴얼 관리를 지원하지 않는다.

## Context Switching 비용

- 쓰레드가 Blocking 되었을 때 다른 쓰레드가 그 자리를 스케쥴링 해야 함
- 쓰레드들은 우선적으로 스케쥴링 되고, 바뀔 동안 모든 레지스터들을 save / restore 해야 함
- 고루틴은 협조적으로 스케쥴링 되고 교체가 일어날 때 오직 3개의 레지스터만이 save / restore 됨 (Program Counter, Stack Pointer, DX)
- 고루틴의 수가 일반적으로 훨씬 더 많지만 교체 시간에 차이를 만들지 않는다.
    - 오직 동작하는 고루틴들만 고려되고, blocking 된 것은 고려되지 않는다.

# 어떻게 고루틴이 실행되는가

- 런타임은 프로그램의 시작부터 끝나는 시점까지 내내 고루틴을 관리한다.
- 런타임은 모든 고루틴을 다중화되어 있는 조금의 쓰레드들에 할당
- 어느 시점에서 각각의 쓰레드는 하나의 고루틴을 실행하게 된고, 그 고루틴이 Blocking 된다면 다른 고루틴으로 교체할 것이다.

# 고루틴 Blocking

- 아래 이유로 blocking 되었을 때 자신이 multiplex된 쓰레드를 블록하지 않는다.
    - 네트워크 입력
    - sleeping
    - 채널 오퍼레이션
    - sync 패키지 primitive들로 인한 블로킹
- 수많은 고루틴이 만들어짐에도 불구하고 만약 대부분의 고루틴들이 위 목록들 중 하나에 Blocking 된다면 런타임이 대신에 또 다른 고루틴을 스케쥴링하기 때문에 시스템 리소스들의 낭비가 아니다.
- 고루틴들은 쓰레드보다 가벼운 관념이다.
- Go 프로그래머는 쓰레드를 다루지 않고, 유사하게 OS는 고루틴의 존재를 알지 못한다.
- OS의 관점에서 Go 프로그램은 이벤트 기반 C프로그램처럼 동작할 것이다.

# 쓰레드와 프로세서

- 런타임이 만들 쓰레드 수를 직접 조정할 순 없더라도, 프로그램에 의해 이용되는 프로세서 코어들의 수는 조정이 가능하다.
- 코어들의 개수를 증가하는 것은 프로그램 성능 증가를 위해 필수적인 것은 아니다.
- 프로파일링 툴들을 프로그래밍을 위한 이상적인 코어 개수를 찾는데 사용할 수 있다.

# 결론

- 고루틴간의 리소스 공유는 Channel을 이용해야 한다.
    - 동시성 문제를 방지하기 위해
  