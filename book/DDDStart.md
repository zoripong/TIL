# 도메인 모델 시작

## 도메인 (domain)

- 소프트웨어로 해결하고자 하는 문제 영역
    - ex. 온라인 서점
- 하나의 도메인은 다시 하위 도메인으로 나눌 수 있다.
    - ex. “온라인 서점”의 경우 아래와 같이 나눌 수 있다.

    ![domain](/static/domain_example.jpeg)

- 소프트웨어가 도메인의 모든 기능을 제공하지는 않는다. 배송, 결제와 같은 도메인의 경우에는 대행 업체를 이용해서 처리할 수 있다.
- 하위 도메인의 구성은 상황에 따라 달라진다.

## 도메인 모델

- 특정 도메인을 개념적으로 표현한 것, 도메인 자체를 이해하기 위한 개념 모델
- 도메인 모델을 이용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.
- 도메인 모델은 객체, 그래프, 상태다이어그램 등 다양한 형태로 표현될 수 있다.
    - 도메인을 이해하는데 도움이 되는 적합한 방법으로 표현하면 된다.
- 개념 모델은 트랜잭션 처리, 성능 등을 고려하지 않고 있기 때문에 실제 코드를 작성할 때에는 개념모델을 그대로 이용할 수 없다. 개념 모델을 바탕으로 구현 모델을 만들어나가야 한다.
    - 개념 모델을 만들 때 처음부터 완벽하게 도메인을 만드는 것은 거의 불가능에 가깝다.
    - 개발하는 동안 도메인에 대해 더 잘 알게 된다.
    - 처음부터 완벽한 개념 모델을 만들기보다 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야 한다.

## 도메인 모델 패턴

### 아키텍쳐 구성

- 사용자 인터페이스 또는 표현 레이어
    - 사용자의 요청을 처리하고 정보를 보여준다.
    - 사용자는 사람뿐만 아니라 시스템도 될 수 있다.
- 응용 레이어
    - 사용자가 요청한 기능을 실행한다.
    - **비즈니스 로직을 직접 구현하지 않고**, 도메인 계층을 조합해서 기능을 실행한다.
- 도메인 레이어
    - 시스템이 제공할 도메인의 규칙을 정의한다.
- 인프라 스트럭쳐
    - 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.

## 도메인 모델 도출

- 도메인을 모델링하기 위해서 요구사항에서 **핵심 구성요소, 규칙, 기능**을 찾아야 한다.
- 모델을 공유할 때는 화이트보드나 위키와 같은 도구를 사용해서 누구나 쉽게 접근할 수 있도록 하면 좋다.

## 문서화

- 문서화의 주된 이유는 지식 공유가 목적
- 실제 구현에 대해서는 코드를 보면 되지만 상세한 모든 내용을 다루고 있어 전체 소프트웨어를 분석하려면 많은 시간을 투자해야 함
- 전반적인 흐름은 상위 수준에서 정리한 문서를 참조하는 것이 빠르게 이해하는데 도움이 된다.
- 코드를 작성할 때 역시 도메인 지식이 잘 묻어나도록 코드를 작성해야 한다.
    - 코드가 문서가 될 수 있게끔

## 엔티티와 밸류

### 엔티티?

- 고유한 식별자를 갖는 객체
    - ex) 주문 도메인에서 각 주문은 서로 다른 주문번호를 가지고 있다.
- 식별자에 의해 각 객체는 구분된다.
- 다른 속성이 바뀌거나 상태가 바뀌더라도 식별자는 변경되지 않는다.
    - ex) 배송지가 변경되어도 주문번호는 유지된다.
- 고유하고 변경되지 않기 때문에 각 객체를 비교할 때 식별자를 통해 비교할 수 있다.

### 엔티티의 식별자

- 특정 규칙에 따라 생성
    - ex) 주문번호
    - 각 식별자들은 고유해야 한다.
- UUID 사용
- 사용자로부터 입력 받기
    - ex) user email
    - 중복해서 입력할 수 없도록 잘 체크해야 한다.
- 일련번호 사용
    - database auto increment

## 밸류?

- 개념적으로 완전한 하나를 표현할 때 사용
    - ex) 주문인 정보
- 값에 의해 각 객체는 구분된다
- 꼭 두 개 이상의 데이터를 가져야 할 필요는 없다.
    - 의미를 명확하게 표현하기 위해 밸류 타입을 사용할 수 있다.
    - ex) Money, 가치를 표현하는 int 타입 하나만 소유하고 있지만 밸류로 표현할 수 있다.
    - 동작에 좀 더 의미를 부여할 수 있다.
        - ex) 돈 계산이 필요할 때 밸류 없이 하게 되면 단순 int 연산이지만, Money 밸류를 통해 표현하면 ‘돈 계산’이라는 것을 명확히 나타낼 수 있다.
- 밸류 객체는 immutable하게 만들어야 한다.
    - set 메소드를 추가하게 된 경우 의도와 다르게 동작할 수 있게 된다.

    ```jsx
    Money price = new Money(1000);
    OrderLine line = new OrderLine(product, price, 2); // price=1000
    price.setValue(2000);  // price=2000
    ```

    - set 메소드를 추가하는 대신에 새로운 객체를 생성해서 반환하는 메소드를 추가해야 한다.

    ```jsx
    String str = "ABC"; // 전형적인 immutable 객체
    str = str.toLowerCase(); // 값을 변경하는 것이 아닌 새로운 인스턴스를 만들어 반환
    ```

- 두 밸류가 같은지 비교할 때는 모든 속성이 같은지 비교해야 한다.

### 엔티티 식별자와 밸류 타입

- 엔티티의 식별자는 단순한 문자열이나 정수가 아니라 도메인에서 특별한 의미를 지니는 경우가 많다.
    - ex) 신용카드의 카드번호, 이메일 주소 등
- 식별자를 위한 밸류 타입을 만들어 의미가 잘 드러나게 할 수 있다.
    - ex) 주문번호를 표현하기 위해 식별자의 타입을 String대시 OrderNo 밸류 타입을 이용할 수 있다.

### 도메인 모델에 set메서드 넣지 않기

- 도메인 모델에 get/set 메소드를 무조건 추가하는 것은 좋지 않다.
- 특히 set의 경우 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- ex) `completePayemnt()` 와 `setOrderState()`를 비교해보았을 때 전자의 경우 결제 완료된 케이스를 구현하지만 후자의 경우 모든 주문 상태 변경 케이스를 다루게 된다.
    - 또한 후자의 경우에는 상태 값에 따라 다른 처리를 할 것인지, 혹은 단순히 상태값만 변경할 것인지 애매하다.
    - 단순히 상태 변경만 하게 되는 경우 상태 변경과 관련된 도메인 지식이 코드에서 사라지게 된다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성자를 통해 **생성 시점에 모든 데이터를 받아야** 한다.
    - 생성자에서 필요한 데이터가 올바른지 검사할 수 있게 된다.
    - 내부적으로 set 메소드를 두고 싶다면 접근제어자를 private으로 걸어 클래스 내부에서 실제로 값을 변경할 목적으로만 사용할 수 있도록 제한을 두어야 한다.
- 불변 밸류 타입을 이용하게 되면 자연스럽게 set 메서드를 구현하지 않는다. 특별한 이유가 없다면 **밸류타입은 불변으로 만들어** 불변 타입의 장점을 살리자.

## 도메인 용어

- 도메인에서 사용하는 용어는 코드에도 반영이 되어야 한다.
- 코드에 반영이 되지 않아있다면 프로그래머는 머릿속으로 도메인 지식으로 코드를 해석해야 한다.
- 의미를 변환하는 과정에서 생기는 버그도 줄어들게 된다.

# 아키텍처 개요

## 네 개의 영역

`표현`, `응용`, `도메인`, `인프라스트럭처` 로 아키텍처를 나눌 수 있다.

### 표현 계층

- 사용자의 요청을 받아 응용 영역에 전달하고, 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할
    - ex) 스프링 MVC 프레임워크
- 표현 영역의 사용자는 사람일 수도, 외부 시스템일 수도 있다.
- HTTP 요청을 응용 영역이 필요로 하는 형식 (객체 등)으로 변환해서 응용 영역에 전달하고, 응용 영역의 응답을 HTTP 응답(JSON 등)으로 변환하여 전송

## 응용 계층

- 로직을 직접 수행하기 보다 도메인 모델에 로직 수행을 위임한다.

### 도메인 계층

- 도메인 모델과 핵심 로직을 구현한다.

### 인프라스트럭처 계층

- 구현 기술에 대한 것을 다룬다.
    - ex) RDBMS 와 연동하여 데이터를 가져오거나 영속화하거나
- 도메인, 응용, 표현 계층에서는 구현 기술을 사용한 코드를 만들지 않고 인프라스트럭처 계층에서 제공하는 기능을 사용하여 필요한 기능을 개발한다.

## 계층 구조 아키텍쳐

- 네 영역으로 아키텍쳐를 구성할 때에는 아래와 같은 계층 구조를 따른다.

![Hierarcy Architecture](/static/hierarchy_architecture.jpeg)

- 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존 x
    - ex) 표현 계층은 응용 계층에 의존하지만 인프라스트럭처 계층은 도메인 계층에 의존하지 않는다.
- 엄격하게 가져가면 상위 계층은 바로 아래 계층에만 의존을 가져간다.
- 그러나 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.
    - ex) 응용 계층에서 바로 인프라스트럭쳐 계층에 의존
- 이러한 구조는 **응용 계층, 도메인 계층이 인프라스트럭쳐의 구체적인 구현에 의존되게 될 수 있다.**
    - ex) 인프라스트럭쳐에서 SQLAlchemy를 이용하여 데이터를 조회해온다고 했을 때 도메인 계층이 SQLAlchemy에 의존하게 되는 경우가 생길 수 있다.
    - 이런 상황이 생기면 SQLAlchemy를 다른 라이브러리로 변경하려고 할 때 인프라스트럭쳐 외에도 도메인 계층도 변경을 해주어야 한다.
    - 또한, 테스트 코드를 작성할 때에도 SQLAlchemy에 대한 설정이 필요해진다.
    - 이러한 문제는 아래 자세히 설명되는 **의존 역전 원칙(DIP)**를 이용하여 해결할 수 있다.

## DIP (Dependency Inversion Principle)

![DIP example](/static/dip_example.jpeg)

- 추상화 시킨 인터페이스를 이용하여 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
- 고수준 모듈 (Service 등) 입장에서 저수준 모듈이 어떻게 구현되었는지는 중요하지 않다.
- 인터페이스를 구현한 저수준 모듈은 DI에 의해 고수준 모듈에 주입되게 된다.
- 구현 기술 교체 문제가 해결된다.
    - 고수준 모듈은 인터페이스에 의존하고 있기 때문에 저수준 구현 객체를 생성하는 부분만 변경하면 된다.
- 테스트를 쉽게 할 수 있다.
    - 고수준 모듈에서 의존하고 있는 인터페이스를 상속받은 Mock 구현체를 만들어 쉽게 테스트가 가능해진다.

### 주의 사항

- 단순히 인터페이스와 구현 클래스를 분리하는 것이 아니다.
- 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.
- 인터페이스가 저수준 모듈에 위치하게 되면 여전히 의존성에 문제가 발생한다.
    - ex)                 도메인 계층                |                         인프라  계층
        - CalculateDiscountService ——> <interface> RuleEngine ← DroolsRuleEngine
- 고수준 모듈에서의 관점에서 필요한 동작을 추상화하여 고수준 모듈에 인터페이스를 두어야 한다.

### DIP와 아키텍쳐

- 아키텍쳐 수준에서 DIP를 적용하면 인프라스트럭처 영역과 응용 영역이 도메인 영역에 의존(상속)하게 된다.
- 응용 영역과 도메인 영역에 영향을 최소화하며 구현체를 변경하거나 추가할 수 있다.

## 도메인 영역의 주요 구성 요소

### 엔티티

- 고유 식별자를 갖는 객체
- 자신의 라이프 사이클을 가짐
- 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능 제공
- DB 테이블의 엔티티와 도메인 모델의 엔티티는 다르다.
    - 도메인 모델의 엔티티는 **데이터와 함께 기능을 제공**한다.
        - 도메인 관점에서 기능을 구현하고 캡슐화하여 데이터가 임의로 변경되는 것을 막는다.
    - 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입으로 표현할 수 있다.
        - DB 테이블의 엔티티는 밸류 타입을 표현하기 힘들다.

### 밸류

- 식별자를 갖지 않는 객체
- 개념적으로 하나의 도메인 객체의 속성을 표현할 때 사용
- 엔티티의 속성이나 다른 밸류 타입의 속성으로 사용된다.
- 값 변경이 필요할 때 새로운 인스턴스를 교체해야 한다.

### 애그리거트

- 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것
    - ex) 수취인, 배송지, 상품 등의 도메인을 묶어서 `주문`이라는 상위 개념으로 표현 가능
- 개별 객체간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현할 수 있다.
- 애그리거트는 루트 엔티티를 갖고, 루트엔티티는 속해있는 엔티티와 밸류를 이용하여 기능을 제공한다.
    - ex) 배송지 변경에 대한 기능을 `주문` 이라는 루트 엔티티 아래에서 기능을 제공한다.
        - 배송지 변경 전 필요한 validation을 하기 편해진다.
    - 루트 엔티티를 통하지 않고는 변경할 수 있는 방법을 제공하지 않는다.

### 리포지터리

- 도메인 모델의 영속성을 처리
- DB에서 데이터를 조회하거나 저장하는 등의 기능을 추상화한 인터페이스
    - 실제 구현은 인프라 스트럭처에서 상속받아 구현
    - 실제 구현체는 DI를 통해 서비스에 주입 됨
- 애그리거트 단위로 저장하고 조회

### 도메인 서비스

- 특정 엔티티에 속하지 않은 도메인 로직 제공
- 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직 구현

## 요청 처리 흐름

![request flow](/static/request_flow.jpeg)

## 인프라스트럭처 개요

- DIP를 이용하여 도메인 영역과 응용 영역의 인터페이스를 구현하는 것이 시스템을 더 유연하게 해준다.
- 그러나 구현의 편리함도 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가도 된다.
- 완전히 의존을 없애다 보면 오히려 구현이 복잡해질 수 있다.
- ex) Spring의 Transactional 어노테이션

## 모듈 구성

- 아키텍처 각 영역은 별도 패키지에 위치한다.
    - com.example
        - ui
        - application
        - domain
        - infrastructure
- 도메인이 커지면 하위 도메인으로 나누고 하위 도메인마다 별도 패키지를 구성한다.
    - com.example
        - catalog
            - ui
            - application
                - product
                - category
            - domain
                - product
                - category
            - infrastructure
        - order
            - ui / application / domain / infrastructure
- 모듈 구조의 세분화야 대해서는 정해진 규칙이 없다.
    - 한 패키지에 너무 많은 타입이 몰려서 불편하지 않을 정도면 괜찮다.
