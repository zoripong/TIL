# kubernetes?
- 컨테이너 오케스트레이션 툴
  - 여러 서버에서 컨테이너 관리
  - 컨테이너 배포
  - 네트워크 관리
  - 부하분산
  - 장애 발생 시 자동 복구

- 선언적으로 오케스트레이션 할 수 있다. (.yaml)
- 컨테이너가 죽었을 때 스스로 복구 시킨다.
- 컴퓨팅 리소스가 낭비되지 않도록 효율적으로 배포 위치를 찾아준다.
- 클러스터 안에 구성 레지스트리를 기반으로 동적으로 애플리케이션이 어디있는지 찾아낸다.

## k8s Components

[k8s diagram](/static/TIL/infra/k8s_cluster_diagram.svg)

### 컨트롤 플레인
- 클러스터에 관한 전반적인 결정을 수행
  - ex) Node의 리소스 사용 상황을 확인하고, 컨테이너를 가동할 노드를 자동으로 선택 등
- 클러스터 이벤트를 감지하고 반응
  - ex) replicas 요구 조건이 충족되지 않은 경우 새로운 파드를 구동 시키는 것 등

#### kube-apiserver
- Node 리소스 정보를 관리하기 위한 REST API
- 각 컴포넌트로부터 리소스 정보를 받아 etcd에 저장하는 역할을 담당
- kubectl 커맨드를 사용하여 API Server에 접근할 수 있음

#### etcd
- 클러스터 구성을 유지하는 분산 Key-Value Store

#### kube-scheduler
- 애플리케이션을 어떤 노드에 배포할지 관리하는 컴포넌트
- 클러스터의 상태를 확인하고, 빈 공간을 가진 노드를 찾아 pod를 실행시키는 스케줄링 담당

#### kube-controller-manager
- 클러스터 상태를 감시하고 본래 되어야 할 상태를 유지하는 컴포넌트
- 사용자가 정의한 상태와 현재 상태를 비교하여, 정의한 상태가 되도록 유지하는 역할 담당

#### cloud-controller-manager
- 클라우드별 컨트롤 로직을 포함하는 컴포넌트
- 클라우드 공급자의 API에 연결하고 클라우드 플랫폼과 상호작용하는 컴포넌트와 클러스터와 상호 작용하는 컴포넌트를 분리할 수 있음
- 로컬에는 k8s 클러스터를 띄울 때에는 존재하지 않음


### Node
- 애플리케이션 컨테이너가 올라가는 서버
- 노드의 개수는 워크로드, 부하, 규모에 따라 다르지만 개수가 늘어날 수록 가용성이 높아진다.

#### kubelet
- Pod에서 스펙에 맞게 컨테이너가 확실히 동작하도록 관리

#### kube-proxy
- 노드에서 실행되는 네트워크 프록시, 서비스의 구현체
- Node의 네트워크 규칙을 유지관리하며 내부 네트워크 세션이나 클러스터 바깥에서 pod로 네트워크 통신할 수 있도록 해줍니다.

#### 컨테이너 런타임
- 컨테이너 실행을 담당하는 소프트웨어

## k8s object
- k8s 시스템에서 영속성을 가지는 오브젝트
- 클러스터의 상태를 나타내기 위해 오브젝트를 이용
  - 어떤 컨테이너화된 애플리케이션이 어느 노드에서 동작 중인지
  - 그 애플리케이션이 이용할 수 있는 리소스
  - 그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지 등의 정책
- 직렬화되어 etcd에 저장됨
- k8s control plane은 모든 오브젝트의 실제 상태를 사용자가 의도한 상태와 일치시키기 위해 계속해서 능동적으로 관리한다.

### 오브젝트 spec과 status
- spec
  - 오브젝트를 생성할 때 리소스의 의도한 상태에 대한 설정
- status
  - k8s에 의해 제공되고 업데이트된 오브젝트의 현재 상태
- 컨트롤 플레인은 계속하여 spec과 status가 일치하도록 끊임없이 관리한다.

### 오브젝트 기술하기
- 오브젝트의 기본 설정과 더불어 의도 상태를 spec에 명시해주어야 한다.
- 대부분의 경우, 정보를 .yaml 파일로 kubectl 에게 제공한다.


#### 요구되는 필드
apiVersion - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지
kind - 어떤 종류의 오브젝트를 생성하고자 하는지
metadata - 이름 문자열, UID, 그리고 선택적인 네임스페이스를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터
spec - 오브젝트에 대해 어떤 상태를 의도하는지

### 네임스페이스

- 네임스페이스는 이름의 범위를 제공
- 네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록 만들어짐
- 네임스페이스 리소스 자체는 네임스페이스에 속하지 않는다.
- 노드나 퍼시스턴트 볼륨과 같은 저수준 리소스는 어느 네임스페이스에도 속하지 않는다.
- 서비스를 생성하면 해당 DNS 엔트리가 생성된다.
    - `<서비스-이름>.<네임스페이스-이름>.svc.cluster.local` 형식
    - 컨테이너가 <서비스-이름>만 사용하는 경우, 네임스페이스 내에 국한된 서비스로 연결
        - 개발, 스테이징, 운영과 같이 여러 네임스페이스 내에서 동일한 설정을 사용하는 경우에 유용

### 레이블과 어노테이션

- 레이블을 사용하여 오브젝트를 선택하고, 특정 조건을 만족하는 오브젝트 컬렉션을 찾을 수 있다.
- 어노테이션은 오브젝트를 식별하고 선택하는데 사용되지 않는다.

# 워크로드

- 워크로드는 쿠버네티스에서 구동되는 애플리케이션
- 워크로드가 단일 컴포넌트이거나 함께 작동하는 여러 컴포넌트이든 관계없이, 쿠버네티스에서는 워크로드를 일련의 파드 집합 내에서 실행
- 쿠버네티스에서 Pod 는 **클러스터에서 실행 중인 컨테이너 집합**을 나타낸다.
- node에 문제가 발생한 경우 사용자는 향후 노드가 복구되는 것과 상관 없이 `Pod` 를 새로 생성해야 함
    - 그러나, 작업이 훨씬 쉽도록, 각 `Pod` 를 직접 관리할 필요는 없도록 만들었다.
    - 대신, 사용자를 대신하여 파드 집합을 관리하는 *워크로드 리소스* 를 사용할 수 있다.
    - 이러한 리소스는 지정한 상태와 일치하도록 올바른 수의 올바른 파드 유형이 실행되고 있는지 확인하는 [컨트롤러](https://kubernetes.io/ko/docs/concepts/architecture/controller/)를 구성한다.

## 파드

- *파드(Pod)* 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.
    - 하나 이상의 [컨테이너](https://kubernetes.io/ko/docs/concepts/containers/)의 그룹이다.
        - 파드당 하나의 컨테이너는 일반적인 유즈케이스, 파드를 컨테이너 wrapper로 볼 수 있다.
        - 밀접하게 결합되어 있고 리소스를 공유해야 하는 여러 개의 컨테이너를 하나의 파드로 묶어 캡슐화 할 수도 있다.
- 각 파드는 **특정 애플리케이션의 단일 인스턴스를 실행하기 위한 것**이다.
    - 수평적으로 확장하려면, **각 인스턴스에 하나씩, 여러 파드를 사용해야 한다**.
    - 쿠버네티스에서는 이를 일반적으로 레플리케이션 이라고 한다.
- 일반적으로 워크로드 리소스와 해당 컨트롤러에 의해 그룹으로 생성되고 관리된다.
- 파드내 컨테이너들은 host, network stack, volume과 같은 리소스를 공유

### 라이프사이클

- 파드의 단계 (phase)
    - 파드의 라이프사이클에 대한 고수준 요약
    - phase 종류
        - pending: 클러스터에 승인 되었으나 아직 실행 준비 전 (이미지 다운로드 시간 포함)
        - running: 노드에 바인딩 및 모든 컨테이너 생성 완료
        - succeeded: 모든 컨테이너들이 성공적으로 종료, 재시작되지 않을 것
        - failed: 모든 컨테이너 종료되었으며, 적어도 하나 이상의 컨테이너가 실패로 종료
        - unknown: 파드의 상태를 얻을 수 없음, 일반적으로 노드와의 통신 오류로 발생
    - * Terminating은 Phase에 포함되지 않음. gracefully 종료되도록 시간이 부여된 것
- 컨테이너 상태
    - `kubectl describe pod <name-of-pod>` 로 확인 가능하다.
    - 상태 종류
        - waiting: 컨테이너 시작을 완료하는데 필요한 작업 중 (이미지 가져오거나, 시크릿 데이터 적용하는 등)
        - running: 문제없이 실행되고 있음
        - terminated: 실행을 시작한 다음 완료될 때까지 실행되었거나 어떤 이유로 실패함
- 컨테이너 재시작 정책
    - restartPolicy로 설정 가능
        - Always(default), OnFailure, Never
    - 파드의 모든 컨테이너에 적용 됨
- 컨테이너 프로브
    - livenessProbe: 컨테이너가 동작 중인지 여부, 실패하면 kubelet이 컨테이너를 죽이고 해당 컨테이너는 재시작 정책의 대싱이 된다. livenessProbe를 제공하지 않으면 기본 값은 Success이다.
    - readinessProbe: 컨테이너가 요청을 처리할 준비가 되었는지에 대한 여부, 실패하면 엔드포인트 컨트롤러는 파드에 연관된 모든 서비스들의 엔드포인트에서 파드 IP를 제거. readinessProbe를 제공하면 초기 값은 Failure이고, readinessProbe를 제공하지 않으면 기본 값은 Success이다.
    - startupProbe: 컨테이너 내의 애플리케이션이 시작되었는지, 성공할 때까지 나머지 프로브는 활성화 되지 않는다. 실패하면 kubelet이 컨테이너를 죽이고 재시작 정책에 따라 처리된다. startupProbe가 없는 경우 기본 값은 Success이다.

### Pod Disruption Budget

- 자발적 중단으로 일시에 중지되는 애플리케이션 파드의 수를 제한한다.
- 실행중인 레플리카의 수가 일정 수 이하로 떨어지지 않도록 한다.
- 만약 2개의 파드를 중단시켜야 하는데 PDB에 명시된 수보다 파드가 줄어든다면 드레이닝과 같은 중단 명령은 일시적으로 거절된다.

## 워크로드 리소스

### Deployment

- 파드와 레플리카셋에 대한 선언적 업데이트를 제공
- 디플로이먼트에서 의도하는 상태를 설명하고, 컨트롤러는 현재 상태에서 의도한 상태로 비율을 조정하며 변경

### ReplicaSet

- 파드 집합의 실행을 항상 안정적으로 유지하는 것
- 동일 파드 개수에 대한 가용성을 보증하는데 사용
- 단독으로 사용될 수 있으나 디플로이먼트를 사용하여 선언하고 관리하는 것을 권장

### StatefulSet

- 디플로이먼트와 비슷하게 컨테이너 스펙을 기반으로 둔 파드들을 관리
- 상태를 유지해야하는 파드들을 관리하는데 사용
    - ex) database
- pod 이름에 대한 규칙성을 부여 할 수 있다.
    - 파드에 uuid가 아는 뜨는 순서대로 0, 1, 2가 붙음
- 노드별 순차적 기동순서가 순차적이다.
    - 0, 1, 2 순으로 뜨고 2, 1, 0 순으로 종료된다.
    - ex) master 기동 후 slave 기동
- 각 Pod마다 PVC(Persistent Volume Claim)와 PV(Persistent Volume)를 생성하여 관리할 수 있다.
    - 볼륨 마운트시 Pod는 Pv를 PVC로 연결해서 정의해야한다.
    - ReplicaSet에서는 Pod 템플릿에 의해 PVC와 PV를 정의하게 되어서 여러 개의 Pod들에 대해서 하나의 PVC와 PV만 정의된다.
    - 1개 이후로 생기는 pod들은 디스크를 사용할 수 없게 된다.

### DeamonSet

- 각 노드에 Pod가 하나씩만 돌게하는 형태로 관리하는 컨트롤러
- 서버 모니터링이나 로그 수집 용도로 많이 사용 됨
- 일부 노드에만 지정하여 띄워줄 수 있음
- kube-proxy도 DeamonSet으로 이뤄져있음

### Job

- 한 번 실행되고 끝나는 형태의 작업을 하는데 사용
- Job이 종료되면 Pod도 같이 종료 됨
- Job을 수행하기 위한 커맨드가 같이 정의 됨
- 만약 프로세스에서 exit코드가 발생하여 실패한 경우 정의해둔 재실행 정책에 따라 재시작하거나 종료한다.
- 순차적 처리(completion), 병렬 처리(parallelism) 모두 설정 가능

### Cronjob

- Job을 주기적으로 자동화하여 실행할 때 사용

# 서비스

- 파드 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법
- 파드는 동적으로 추가 삭제되기 때문에 파드의 IP를 활용하여 로드밸런싱하는 것이 어려움
    - 서비스를 이용해서 파드 집합을 선택할 수 있도록 함
- 클러스터내 프론트엔드 클라이언트는 백엔드 세트를 구성하는 파드가 변경되는 여부를 신경 쓸 필요 없으며 서비스를 통해서 이러한 디커플링이 가능해진다.
- selector를 통해서 네트워크 요청을 라우팅할 파드 세트를 결정할 수 있으며, 어떤 port로 포워딩할 것인지 결정가능하다.
    - 보통 편의상 targetPort와 port를 통일한다.
    - selector를 지정하지 않을 수 있으며 이때는 Endpoint 오브젝트를 직접 추가해주어야 한다.
- 바로 서비스 앞단에 reverse-proxy (혹은 load balancer)를 위치시키는 것이죠. 클라이언트에서 proxy로 연결을 하면 proxy의 역할은 서버들 목록을 관리하며 현재 살아있는 서버에게 트래픽을 전달하는 것입니다. 이는 proxy 서버가 몇가지 요구사항을 만족해야합니다. proxy 서버 스스로 내구성이 있어야 하며 장애에 대응할 수 있어야 합니다. 또한 트래픽을 전달할 서버 리스트를 가지고 있어야 하고 해당 서버가 정상적인지 확인할 수 있는 방법을 알아야 합니다.
- Kube proxy
- 그것은 어떤 소프트웨어를 어떻게 설정해야 하는지에 대한 정보가 저장되어 있는 리소스였습니다.

# Ingress

- 클러스터 내의 서비스에 대한 외부 접근을 관리하는 오브젝트
- 인그레스 컨트롤러가 있어야 인그레스 오브젝트가 효과적으로 동작할 수 있다.
- HTTP 요청을 기반으로 라우팅을 할 수 있음

# configmap vs secrets

- secrets은 base64로 인코딩하여 정의하지만 configmap은 일반텍스트
- secrets은 암호화 되지만 configmap은 아님
- secrets은 배포마다 데이터를 업데이트하지만 configmap은 변경시에만

# 볼륨

- 컨테이너 내 디스크에 있는 파일은 임시적이며, 컨테이너가 크래시 될 때 파일이 손실되고 Pod에서 같이 실행되는 컨테이너간에 파일을 공유할 때 문제가 발생한다.
- 임시 볼륨 유형은 파드와 수명이 동일하지만, 퍼시스턴트 볼륨은 파드의 수명을 넘어 존재한다.
    - 퍼시스턴트 볼륨의 경우 파드가 다시 시작되더라도 데이터가 보존된다.
- 파드가 더 이상 존재하지 않을 경우 임시 볼륨은 삭제되지만, 퍼시스턴트 볼륨은 유지된다.
- 기본적으로 볼륨은 일부 데이터가 있을 수 있는 디렉터리일 뿐이며 파드 내 컨테이너에서 접근할 수 있다.

## 참고 자료
- https://kubernetes.io/ko/docs/concepts/overview/components/