# 동시성과 병렬성

![concurrent.png](/static/TIL/cs/concurrent.png)

## 동시성

- 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식
- 여러 개의 스레드가 번갈아가면서 실행되는 성질
- 병렬적으로 보이지만 사실은 번갈아가면서 조금씩 실행되는 것
- Single Thread 환경에서도 concurrent한 작업을 수행할 수 있다.
    - CPU time-slicing 혹은 Application level의 scheduling을 활용

## 병렬성

- 멀티 코어에서 멀티 스레드를 동작시키는 방식
- 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질
- Parallel한 작업은 Concurrent하다. 그 반대는 항상 성립하지 않는다.

### 데이터 병렬성 (Data Parallelism)

전체 데이터를 쪼개 서브 데이터들로 만든 뒤, 서브 데이터들을 병렬 처리하여 작업을 빠르게 수행하는 것

### 작업 병렬성 (Task Parellelism)

서로 다른 작업을 병럴 처리하는 것 

# **프로세스**

![process.png](/static/TIL/cs/process.png)

- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 각각 독립된 메모리 영역(code, data, stack, heap의 구조)를 할당
    - stack: 지역변수 할당과 함수 호출 시 전달되는 인자값들의 저장하기 위한 공간. ex) int a = 10
    - heap: **동적 할당**을 위해 존재하는 공간. ex) new malloc
    - data: global, static 변수의 할당을 위한 공간. ex) static int a = 10;
    - bss : data영역과 같으나 init되지 않은 변수를 위한 공간.
    - code(text): 실행파일 내에 존재하는 명령어를 위한 공간.
- 프로세스당 최소 1개의 스레드를 가지고 있음
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 불가능

## 멀티 프로세스

- fork를 통해 프로세스를 복사하여 환경변수 및 프로세스 핸들 테이블은 상속가능하지만 각자의 메모리 영역을 가진다.
- 프로세스간 통신을 하기 위해서는 IPC (Inter Process Communication)을 통해야 한다.
- 각각 독립적으로 상태를 유지하고 있다보니 컨텍스트 스위칭을 하는데 비교적 비용이 많이 들어가게 된다.

> context switching: 동작중이던 프로세스의 상태를 보관하고 다음 순번의 프로세스의 상태를 복구하는 과정

# **스레드**

- **프로세스 내에서** 실행되는 여러 흐름의 단위
    - 프로세스는 기본적으로 1개의 스레드를 가지고 있고 이것을 메인 스레드라고 부른다.
- 스레드는 프로세스 내에서 각각 Stack영역만 따로 할당 받고, code, data, heap 영역은 공유한다.
    - stack을 따로 할당 받는 이유는 스택은 함수 호출 시 전달되는 인자, 되돌아 갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다.
    - 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것
    - 스레드의 정의에 따라 독립적인 실행 흐름을 가지기 위한 최소 조건으로 독립된 스택을 할당한다.

## 멀티 스레드

- 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상
- 하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해줌
    - 분산처리를 통해 동시에 실행되는 것 처럼 보이는 것

### 장점

- 응답성
    - 일부분이 중단되거나 긴 작업을 수행하더라도 사용자에 대한 응답성 증가
- 경제성
    - 프로세스 내 자원들과 메모리를 공유하기 때문에 자원소모가 줄어든다.
    - 스레드간 통신이 필요한 경우에도 쉽게 주고 받을 수 있다.
    - 프로세스의 context-switching과 달리 스레드 간의 context-switching은 메모리를 비울 필요가 없어서 더 빠르다.
- 멀티프로세서 활용시 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다.
    - 단일 프로세서에서는 스케쥴링을 통해 concurrent하게 처리된다. (not Parellelism)

### 단점

- 임계 영역 (둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드 블록)
    - 프로세스와 달리 자원을 공유하기 때문에 공유하는 자원에 동시에 접근하는 경우 값의 정합성이 떨어지게 됨 (race condition)
    - 동기화를 통해 스레드의 작업 처리 순서와 공유 자원에 대한 접근을 컨트롤 가능
        - 그러나 불필요한 부분까지 동기화 하는 경우 과도한 lock으로 인해 병목 현상이 발생될 수 있다.
        - 동기화 방법으로는 mutex, semaphore가 있음
- context switching 으로 인해 단일 스레드보다 느리다.
- 디버깅이 까다로움

# 코루틴

- 코루틴은 실제로 병렬로 수행되지 않고 여러 개의 작업을 잘게 쪼개 작업을 수행
- 한 번에 하나의 코드만 실행 (비동기가 아니며, 동시에 처리되지 않는다.)
- context switching이 적어 성능면에서 멀티 스레드보다 좋다.
- 힙 영역에 객체 형태로 적재된다.
- 스레드는 OS가 스케줄링 하지만, 코틀린은 프로그래머가 스케줄링한다.
- 협력형 멀티태스킹을 구현하는 용도이기 때문에 선점형 멀티태스킹과 달리 운영체제의 개입 없이 각 task가 독점적으로 CPU를 사용하고 사용기 끝나면 양보하는 방식이다.
    - 따라서, 임계구역을 보호하기 위한 동기화수단이 필요 없다.
- 일시 중단 기능을 이용해 하나의 스레드에서 여러가지 작업들을 처리할 수 있으므로 기존의 스레드를 직접 다루어 처리하던 방식보다 시스템 자원을 훨씬 효율적으로 사용할 수 있다.

## 제어권 전달 방식

### symmetric

- 코루틴이 멈출 때 제어권을 넘겨받을 다른 코루틴을 지정하는 방식

### asymmetric

- 코루틴이 멈추면 제어권을 주었던 지점으로 돌아가는 방식
- 구조적 프로그래밍에 가까우며 이해하고 사용하기 편하다.
- 파이썬의 제너레이터는 비대칭 코루틴이며 asyncio를 이용하여 대칭 코루틴으로 확장시킬 수 있다.

# 병렬성 프로그래밍에서 발생할 수 있는 문제점

![trouble_in_concurrent.png](/static/TIL/cs/trouble_in_concurrent.png)

- CPU가 작업을 처리하기 위해서 RAM의 일부분을 CPU cache memory로 읽어들이고, 작업이 완료되면 역순으로 해당 과정을 거친다.
- 적절한 시점에 CPU cache memory에서 RAM으로 쓰기 작업이 일어나는데, CPU가 캐시에 쓰기 작업을 수행했다고 해서 바로 RAM으로 쓰기 작업을 수행할 필요가 없다는 것이다.

## 가시성 문제 (visibility)

- 1번 스레드가 공유 변수를 업데이트 하더라도 CPU cahce memory가 RAM에 즉각적으로 업데이트를 하지 않으면 2번 스레드는 업데이트된 데이터를 확인할 수 없다.
- CPU Cache Memory를 거치지 않고 RA으로 직접 쓸 수 있도록 하여 해결할 수 있다.
    - 자바에서는 volatile 키워드를 통해 지정할 수 있다.

## 동시 접근 문제

- 1번 스레드와 2번스레드가 공유 자원 count를 1000번 +1하는 상황에서
- 1번 스레드와 2번 스레드가 동시에 RAM으로부터 공유 자원 count를 읽어오고 난 후 +1을 해주면, RAM에 동일한 결과가 중복으로 저장되게 된다.
- 순차적으로 동작했다면 +2가 되어야하지만 중복으로 저장되어 +1밖에 되지 않는다.

# 공유 자원 관리

- 임계 구역 (critical section)
    - 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
    - 공유 데이터를 여러 프로세스가 접근하면 잘못된 결과를 만들 수 있기 때문에 한 프로세스가 임계 구역을 사행 할 때에는 다른 프로세스가 접근하지 못하도록 막아야 함
- race condition
    - 두 개 이상의 스레드가 공유 자원에 동시에 접근하여 변경하려고 하는 경우 발생하는 문제

## Mutex

- 임계영역에 들어갈 때 lock을 걸어 다른 프로세스 혹은 스레드가 접근하지 못하도록 하고 임계 구역에서 나올 때 락을 해제하는 방법

## Semaphore

- 임계영역에 접근할 수 있는 최대 허용치를 가지고 있는 방법
- 프로세스 혹은 스레드가 접근했을 때 semWait(-1), 나올 때 semSignal(+1)을 함
- 1 이상일 경우 새로 접근할 수 있도록 함

## Mutext vs Semaphore

- mutex는 오직 1개만의 프로세스 혹은 스레드만이 접근 가능하며 반드시 lock을 획득한 프로세스가 그 lock을 해제해야 함
- semaphore는 semaphore의 변수만큼 프로세스 혹은 스레드가 접근 가능하고, lock을 건 프로세스가 아닌 다른 프로세스도 lock을 해제할 수 있음
- 세마포어는 뮤텍스가 될 수 있으나 뮤텍스는 세마포어가 될 수 없다.
    - 세마포어의 변수가 1이라면 mutex가 될 수 있음
- 세마포어는 파일시스템 상에서 파일형태로 존재하고, 뮤텍스는 프로세스 범위에 존재
    - 뮤텍스는 프로세스가 사라질 때 같이 clean up 됨

# 교착상태

- 시스템 자원에 대한 요구가 뒤엉킨 상태
- 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

## 필요 충분 조건

아래 조건이 모두 만족한 경우 시스템은 교착상태에 빠진다.

### 상호 배제

한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.

### 점유 대기

자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

### 비선점

이미 할당된 자원을 강제로 빼앗을 수 없다.

### 순환 대기

대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

## 해결법

### 예방하기

- 자원의 상호 배제 조건 방지
    - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있도록 한다.
    - 동기화 문제가 발생할 수 있다.
- 점유 대기 조건 방지
    - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하여서 다른 자원 점유를 위해 대기하지 않도록 한다.
- 비선점 조건 방지
    - 이미 다른 프로세스에게 할당된 자원이 선점권이 없을 때 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록
- 순환 대기 조건 방지
    - 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.

위 방법을 통해 데드락을 예방하는 것은 시스템의 처리량이나 효율성을 떨어뜨리는 단점이 발생할 수 도 있다.

### 회피

- 안전 상태 (Safe State)
    - 프로세스들이 요청하는 모든 자원을 데드락을 발생시키지 않고 차례로 모두에게 할당해줄 수 있는 상태
- 안전 순서 (Safe Sequence)
    - 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있는 것
- 은행원 알고리즘
    - 어떤 자원의 할당을 허용하는지 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 하여 safe state에 들 수 있는지 여부를 검사하는 것
    - 대기중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것
    - 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원의 수가 일정해야 하는 등의 제약 조건이 있다.

### 교착상태 탐지 및 회복

- 탐지 기법
    - allocation, request, available 등으로 시스템에 데드락이 발생했는지 여부를 탐색
        - 현재 시스템의 자원 할당 상태를 가지고 파악해야 함
    - 자원 할당 그래프를 통해 탐지
- 회복 기법
    - 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법 사용
        - 프로세스 1개 이상 중단 시키기
            - 교착 상태에 빠진 모든 프로세스 중단시키기
            - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하며 회복시키기
        - 자원 선점하기